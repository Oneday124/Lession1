# У вас есть код, который вы не можете менять (так часто бывает, когда код в глубине программы используется
# множество раз и вы не хотите ничего сломать):
# transformation = <???>
# values = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] # или любой другой список
# transormed_values = list(map(transformation, values))
# Единственный способ вашего взаимодействия с этим кодом - посредством задания функции transformation.
# Однако вы поняли, что для вашей текущей задачи вам не нужно никак преобразовывать список значений, а
# нужно получить его как есть.
# Напишите такое лямбда-выражение transformation, чтобы transformed_values получился копией values.

# transformation = lambda x: x
# values = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
# transormed_values = list(map(transformation, values))
# assert values == transormed_values
#
# print(id(values))
# print(id(transormed_values))

# Планеты вращаются вокруг звезд по эллиптическим орбитам. Назовем самой далекой планетой ту, орбита которой
# имеет самую большую площадь. Напишите функцию find_farthest_orbit(list_of_orbits), которая среди списка орбит
# планет найдет ту, по которой вращается самая далекая планета. Круговые орбиты не учитывайте: вы знаете, что у
# вашей звезды таких планет нет, зато искусственные спутники были были запущены на круговые орбиты. Результатом
# функции должен быть кортеж, содержащий длины полуосей эллипса орбиты самой далекой планеты. Каждая орбита
# редставляет из себя кортеж из пары чисел - полуосей ее эллипса. Площадь эллипса вычисляется по формуле
# S = pi*a*b, где a и b - длины полуосей эллипса. При решении задачи используйте списочные выражения.
# Подсказка: проще всего будет найти эллипс в два шага: сначала вычислить самую большую площадь эллипса,
# а затем найти и сам эллипс, имеющий такую площадь. Гарантируется, что самая далекая планета ровно одна
# Ввод:
# orbits = [(1, 3), (2.5, 10), (7, 2), (6, 6), (4, 3)] print(*find_farthest_orbit(orbits))
# Вывод:
# 2.5 10

# Решение группы:
# def _res(arr: list) -> list:
#     max_orbit = max(map(lambda a: a[0] * a[1], filter(lambda a: a[0] != a[1], arr)))
#     return list(filter(lambda a: a[0] * a[1] == max_orbit, arr))
#
# orbits = [(1, 3), (2.5, 10), (7, 2), (6, 6), (4, 3)]
# print(_res(orbits))

# Решение преподавателя:

# def find_farthest_orbit(orbits):
#     return max(orbits, key = lambda x: (x[0] != x[1]) * x[0] * x[1])
#
# orbits = [(1, 3), (2.5, 10), (7, 2), (6, 6), (4, 3)]
# print(find_farthest_orbit(orbits))

# Мое решение:
# orbits = [(1, 3), (2.5, 10), (7, 2), (6, 6), (4, 3)]
# def find_farthest_orbit(list_of_orbits):
#     maxS = 0
#     t = ()
#     for i in orbits:
#         a, b = i
#         x = 3.14 * a * b
#         if maxS < x and a != b:
#             maxS = x
#             t = i
#     return t
# print(find_farthest_orbit(orbits))

